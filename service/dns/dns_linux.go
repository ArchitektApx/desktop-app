package dns

import (
	"fmt"
	"net"
	"os"

	"github.com/fsnotify/fsnotify"
)

var (
	resolvFile       string = "/etc/resolv.conf"
	resolvBackupFile string = "/etc/resolv.conf.ivpnsave"

	manualDNS net.IP = nil

	done chan struct{}
)

func init() {
	done = make(chan struct{})
}

func implPause() error {
	return implDeleteManual(nil)
}

func implResume() error {
	if manualDNS == nil {
		return implDeleteManual(nil)
	}

	return implSetManual(manualDNS, nil)
}

// Set manual DNS.
// 'addr' parameter - DNS IP value
// 'localInterfaceIP' - not in use for macOS implementation
func implSetManual(addr net.IP, localInterfaceIP net.IP) error {
	if addr == nil {
		return implDeleteManual(nil)
	}

	if _, err := os.Stat(resolvBackupFile); err != nil {
		// if no backup exists - create backup of DNS configuration

		if _, err := os.Stat(resolvFile); err == nil {
			// if DNS-config exists
			if err := os.Rename(resolvFile, resolvBackupFile); err != nil {
				return fmt.Errorf("failed to backup DNS configuration: %w", err)
			}
		}
	} else {
		// do nothing if we already changed DNS
		return nil
	}

	saveNewConfig := func() error {
		out, err := os.OpenFile(resolvFile, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, 0644)
		if err != nil {
			return fmt.Errorf("failed to update DNS configuration (%w)", err)
		}

		if _, err := out.WriteString(fmt.Sprintln(fmt.Sprintf("# resolv.conf autogenerated by '%s'\n\nnameserver %s", os.Args[0], addr.String()))); err != nil {
			return fmt.Errorf("failed to change DNS configuration: %w", err)
		}

		if err := out.Sync(); err != nil {
			return fmt.Errorf("failed to change DNS configuration: %w", err)
		}
		return nil
	}
	// Save new configuration
	if err := saveNewConfig(); err != nil {
		return err
	}

	manualDNS = addr

	// enable file change monitoring
	go func() {
		w, err := fsnotify.NewWatcher()
		if err != nil {
			log.Error(fmt.Errorf("failed to start DNS-change monitoring (fsnotify error): %w", err))
			return
		}

		log.Info("DNS-change monitoring started")
		defer func() {
			w.Close()
			log.Info("DNS-change monitoring stopped")
		}()

		for {
			// start watching file
			err = w.Add(resolvFile)
			if err != nil {
				log.Error(fmt.Errorf("failed to start DNS-change monitoring (fsnotify error): %w", err))
				return
			}

			// wait
			var evt fsnotify.Event
			select {
			case evt = <-w.Events:
				break
			case <-done:
				// monitoring stopped
				return
			}

			//stop watching file
			if err := w.Remove(resolvFile); err != nil {
				log.Error(fmt.Errorf("failed to remove warcher (fsnotify error): %w", err))
			}

			// restore DNS configuration
			log.Info(fmt.Sprintf("DNS-change monitoring: DNS was changed outside [%s]. Restoring ...", evt.Op.String()))
			if err := saveNewConfig(); err != nil {
				log.Error(err)
			}
		}

	}()

	return nil
}

// DeleteManual - reset manual DNS configuration to default
// 'localInterfaceIP' (obligatory only for Windows implementation) - local IP of VPN interface
func implDeleteManual(localInterfaceIP net.IP) error {
	// stop file change monitoring
	select {
	case done <- struct{}{}:
		break
	default:
		break
	}

	if _, err := os.Stat(resolvBackupFile); err != nil {
		// nothing to restore
		return nil
	}

	// restore original configuration
	if err := os.Rename(resolvBackupFile, resolvFile); err != nil {
		return fmt.Errorf("failed to restore DNS configuration: %w", err)
	}

	return nil
}
